<!DOCTYPE html>

<html lang="zh">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Retro-Futurism Concept Show</title>

    <style>

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }

        canvas { display: block; }



        /* 顶部 UI 装饰 */

        #hud {

            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);

            color: #ff00ff; text-align: center; pointer-events: none; z-index: 10;

            text-shadow: 0 0 10px #ff00ff;

        }

        .glitch { font-size: 24px; font-weight: bold; letter-spacing: 5px; text-transform: uppercase; }



        /* 隐藏原始摄像头，仅保留逻辑 */

        #cam-container {

            position: absolute; bottom: 20px; left: 20px;

            width: 120px; height: 90px; border: 1px solid #ff00ff;

            opacity: 0.3; transform: scaleX(-1); overflow: hidden;

        }

        #cam-video { width: 100%; height: 100%; object-fit: cover; }



        .status { font-size: 10px; color: #00ffff; margin-top: 5px; }

    </style>



    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

</head>

<body>



    <div id="hud">

        <div class="glitch">NEON GENESIS</div>

        <div class="status" id="status-text">SYSTEM: STANDBY_</div>

    </div>



    <div id="cam-container">

        <video id="cam-video" playsinline muted autoplay></video>

    </div>



    <script>

        // ================= 1. 核心场景设置 =================

        const scene = new THREE.Scene();

        scene.fog = new THREE.FogExp2(0x1a0b2e, 0.015);



        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        camera.position.set(0, 15, 45);

        camera.lookAt(0, 8, 0);



        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.setClearColor(0x0a0510);

        document.body.appendChild(renderer.domElement);



        // ================= 2. 交互变量 =================

        let handData = { x: 0.5, y: 0.5, size: 0.2, active: false };

        let targetIntensity = 1.0;

        let currentIntensity = 1.0;



        // ================= 3. 增强版着色器 (还原原图质感) =================

        const terrainVertex = `

            varying vec2 vUv;

            varying float vDisp;

            uniform float uTime;

            uniform float uHeightControl;

            uniform float uXOffset;



            float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

            float noise(vec2 p) {

                vec2 i = floor(p); vec2 f = fract(p);

                vec2 u = f*f*(3.0-2.0*f);

                return mix(mix(hash(i + vec2(0,0)), hash(i + vec2(1,0)), u.x),

                           mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);

            }



            void main() {

                vUv = uv;

                vec3 pos = position;



                // 模拟原图：两侧山脉，中间开阔路面

                float distFromCenter = abs(pos.x);

                float roadWidth = 8.0;

                float mountainMask = smoothstep(roadWidth, roadWidth + 25.0, distFromCenter);



                // 动态噪声叠加

                float n = noise(pos.xz * 0.1 - vec2(0.0, uTime * 0.8));

                n += noise(pos.xz * 0.2) * 0.5;



                // 手势大幅度影响：uHeightControl 映射手势高度

                float elevation = n * 18.0 * uHeightControl * mountainMask;

                pos.y += elevation;

                vDisp = pos.y;



                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

            }

        `;



        const terrainFragment = `

            varying vec2 vUv;

            varying float vDisp;

            uniform float uTime;

            uniform float uHue;



            void main() {

                // 经典的复古网格

                vec2 grid = abs(fract(vUv * vec2(30.0, 60.0) - vec2(0.0, uTime * 0.5)) - 0.5);

                float line = 0.01 / min(grid.x, grid.y);



                // 颜色根据手势横向移动(uHue)变化

                vec3 colorA = vec3(0.9, 0.0, 0.5); // 玫红

                vec3 colorB = vec3(0.0, 0.8, 1.0); // 青蓝

                vec3 baseColor = mix(colorA, colorB, uHue);



                // 亮度随海拔提升

                float glow = vDisp * 0.15;

                vec3 finalColor = baseColor * (line + glow);



                // 远景淡出

                float fog = smoothstep(0.0, 0.9, 1.0 - vUv.y);

                gl_FragColor = vec4(finalColor * fog, 1.0);

            }

        `;



        // ================= 4. 创建物体 =================



        // 地形

        const geometry = new THREE.PlaneBufferGeometry(200, 200, 100, 100);

        geometry.rotateX(-Math.PI / 2);

        const terrainUniforms = {

            uTime: { value: 0 },

            uHeightControl: { value: 1.0 },

            uHue: { value: 0.5 }

        };

        const terrainMat = new THREE.ShaderMaterial({

            vertexShader: terrainVertex,

            fragmentShader: terrainFragment,

            uniforms: terrainUniforms,

            transparent: true

        });

        const terrain = new THREE.Mesh(geometry, terrainMat);

        scene.add(terrain);



        // 太阳 (原图核心)

        const sunGeom = new THREE.CircleBufferGeometry(25, 64);

        const sunMat = new THREE.ShaderMaterial({

            uniforms: { uTime: { value: 0 }, uIntensity: { value: 1.0 } },

            vertexShader: `

                varying vec2 vUv;

                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }

            `,

            fragmentShader: `

                varying vec2 vUv;

                uniform float uTime;

                uniform float uIntensity;

                void main() {

                    float dist = distance(vUv, vec2(0.5));

                    if(dist > 0.5) discard;



                    // 百叶窗条纹效果

                    float stripes = step(0.12, fract(vUv.y * 12.0 - uTime * 0.2));

                    vec3 color = mix(vec3(1.0, 0.8, 0.0), vec3(1.0, 0.0, 0.5), vUv.y);

                    gl_FragColor = vec4(color * stripes * uIntensity, 1.0);

                }

            `,

            transparent: true

        });

        const sun = new THREE.Mesh(sunGeom, sunMat);

        sun.position.set(0, 18, -80);

        scene.add(sun);



        // 星辰粉尘

        const starsGeom = new THREE.BufferGeometry();

        const starsPos = [];

        for(let i=0; i<2000; i++) {

            starsPos.push((Math.random()-0.5)*300, Math.random()*100, -Math.random()*200);

        }

        starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starsPos, 3));

        const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({color: 0xffffff, size: 0.4, transparent: true}));

        scene.add(stars);



        // ================= 5. 手势逻辑集成 =================

        const videoElement = document.getElementById('cam-video');

        const statusText = document.getElementById('status-text');



        function onResults(results) {

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {

                handData.active = true;

                const landmarks = results.multiHandLandmarks[0];



                // 1. 手势高度 -> 地形高度 (大幅度响应)

                handData.y = 1.0 - landmarks[8].y;



                // 2. 手势左右 -> 色彩偏移

                handData.x = landmarks[8].x;



                // 3. 手掌张合程度 (食指与大拇指距离) -> 太阳能量

                const dist = Math.sqrt(

                    Math.pow(landmarks[4].x - landmarks[8].x, 2) +

                    Math.pow(landmarks[4].y - landmarks[8].y, 2)

                );

                targetIntensity = dist * 8.0; // 距离越大，能量越强



                statusText.innerText = "LINKED: CREATOR_MODE_ON";

                statusText.style.color = "#ff00ff";

            } else {

                handData.active = false;

                targetIntensity = 1.0;

                statusText.innerText = "SYSTEM: SEARCHING_FOR_HAND_";

                statusText.style.color = "#00ffff";

            }

        }



        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });

        hands.onResults(onResults);



        const cam = new Camera(videoElement, {

            onFrame: async () => { await hands.send({image: videoElement}); },

            width: 320, height: 240

        });

        cam.start();



        // ================= 6. 渲染循环 =================

        const clock = new THREE.Clock();



        function animate() {

            requestAnimationFrame(animate);

            const t = clock.getElapsedTime();



            // 平滑插值

            currentIntensity += (targetIntensity - currentIntensity) * 0.1;

            let hFactor = handData.active ? handData.y * 2.5 : 1.0;



            // 更新 Uniforms

            terrainUniforms.uTime.value = t;

            terrainUniforms.uHeightControl.value = hFactor;

            terrainUniforms.uHue.value = handData.active ? handData.x : 0.5;



            sunMat.uniforms.uTime.value = t;

            sunMat.uniforms.uIntensity.value = currentIntensity;



            // 星辰微动

            stars.position.z = (t * 10) % 100;



            renderer.render(scene, camera);

        }

        animate();



        // 自适应屏幕

        window.addEventListener('resize', () => {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        });

    </script>

</body>

</html>