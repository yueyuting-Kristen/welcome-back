// ================= 1. 核心变量 =================
        let audioCtx, analyser, dataArray;
        let audioStarted = false;
        let handData = { x: 0.5, y: 0.2, active: false, isOpen: true }; // 增加手势开合状态
        let smoothBass = 0, smoothHigh = 0, smoothMid = 0;
        let smoothHandY = 0.2; 
        let smoothSunIntensity = 1.0; // 太阳亮度平滑变量

        // ================= 2. 场景设置 (保持不变) =================
        // ... 此处省略你之前的场景代码 ...

        // ================= 3. 着色器修改 (太阳色调改为橙红) =================
        const sunMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uIntensity: { value: 1.0 } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                varying vec2 vUv; uniform float uTime; uniform float uIntensity;
                void main() {
                    float dist = distance(vUv, vec2(0.5));
                    if(dist > 0.5) discard;
                    float stripes = step(0.12, fract(vUv.y * 12.0 - uTime * 0.1));
                    // 修改为橙红色调：深红到亮橙的渐变
                    vec3 color = mix(vec3(0.8, 0.1, 0.0), vec3(1.0, 0.4, 0.0), vUv.y);
                    gl_FragColor = vec4(color * stripes * uIntensity, 1.0);
                }`,
            transparent: true
        });
        const sun = new THREE.Mesh(new THREE.CircleBufferGeometry(28, 64), sunMat);
        sun.position.set(0, 18, -100);
        scene.add(sun);

        // ================= 4. 音频系统 (保持你之前的 music.mp3 逻辑) =================
        // ... 此处省略音频初始化代码 ...

        // ================= 5. 手势识别 (增加开合检测) =================
        const videoElement = document.getElementById('cam-video');
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.active = true;
                const lm = results.multiHandLandmarks[0];
                handData.y = 1.0 - lm[8].y; 
                handData.x = lm[8].x; // 左右位置

                // 检测手掌开合：计算大拇指尖(4)和食指尖(8)的距离
                const dx = lm[4].x - lm[8].x;
                const dy = lm[4].y - lm[8].y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                handData.isOpen = distance > 0.15; // 距离阈值判定开合

                document.getElementById('status-text').innerText = handData.isOpen ? "SYSTEM: EXPAND_" : "SYSTEM: CONTRACT_";
            } else {
                handData.active = false;
                document.getElementById('status-text').innerText = "SYSTEM: SEARCHING_";
            }
        });
        const cam = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cam.start();

        // ================= 6. 渲染循环 =================
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            let bass = 0;
            if (audioStarted && analyser) {
                analyser.getByteFrequencyData(dataArray);
                for(let i=0; i<6; i++) bass += dataArray[i];
                bass = (bass / (6 * 255));
                smoothBass += (bass - smoothBass) * 0.12;
            }

            // 1. 颜色变化：利用手部 X 坐标控制山脉色相 (0.0 - 1.0)
            terrainUniforms.uHue.value = handData.active ? handData.x : 0.5;

            // 2. 太阳亮度：根据手掌开合调整基础亮度
            const targetIntensity = handData.active ? (handData.isOpen ? 2.5 : 0.4) : 1.0;
            smoothSunIntensity += (targetIntensity - smoothSunIntensity) * 0.1;

            terrainUniforms.uTime.value = t;
            terrainUniforms.uHeightControl.value = (smoothHandY * 3.8) + (smoothBass * 1.5);
            
            sunMat.uniforms.uTime.value = t;
            // 最终太阳亮度 = 手势亮度 + 音频低音跳动
            sunMat.uniforms.uIntensity.value = smoothSunIntensity + smoothBass * 2.0;

            renderer.render(scene, camera);
        }
